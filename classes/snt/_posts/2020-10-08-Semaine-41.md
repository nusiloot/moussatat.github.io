---
layout: post 
categories: ['classes','SNT']
title : "S√©quence 0 - Codage de nombres et caract√®res (2h)"
subtitle: "Semaine 41(2h)"
date: 2020-10-08 
tags: [snt]
comments: false
social-share: false
--- 
{: .box-error}
Vous travaillerez et testerez vos scripts sur le site [**basthon**](https://python.infobrisson.fr/) ou directement sur votre pythonette.  
Enregistrer les r√©ponses aux exercices et activit√©s dans un fichier. Le nom du fichier indiquera la date et noms des √©l√®ves du groupe et sera t√©l√©vers√© dans le dossier [nextcloud](https://cloud-grenoble.beta.education.fr/s/C35CGGgzDaCJQ8Z)


{: .box-note} 
## Le syst√®me binaire

Les ordinateurs transforment toutes les donn√©es en nombres et manipulent uniquement des nombres. Ces nombres sont stock√©s sous la forme de listes de 0 et de 1. C'est l'√©criture binaire des nombres ! 

Dans le syst√®me d√©cimal, celui qui nous est familier, nous utilisons dix chiffres, de 0 √† 9.  La position des chiffres repr√©sente le nombre de puissances de 10 : d‚Äôabord $$10^0$$ (soit 1), puis $$10^1$$ (10), puis $$10^2$$ (100), puis $$10^3$$ (1000) et ainsi de suite.
 
Pour le nombre d√©cimal 70685, le chiffre le plus √† droite repr√©sente les unit√©s, le chiffre situ√© juste √† sa gauche les dizaines puis arrivent les centaines, les milliers et ainsi de suite.

| $$10^{4}$$ | $$10^{3}$$	 |	 $$10^{2}$$  | $$10^{1}$$   | $$10^{0}$$  | 
| :--: | :-----------: | :-----------:  |:-----------:  |:-----------:- |
| 7 | 0	 |	 6  | 8 | 5 |  


Dans une num√©ration binaire, seuls 2 chiffres sont utilis√©s : 0 et 1. Un nombre binaire se pr√©sente sous forme particuli√®re, par exemple $$1.0.1$$, $$1.0.1.1.1.1$$ ou $$1.1.1.1.0.0.1.1$$ (prononcer les chiffres un √† un).

La position d'un **chiffre binaire** est appel√©e **bit** ( de l'anglais **BInary digiT** )  et repr√©sente une puissance de 2. 

L'√©criture binaire $$1.0.1.1.0.0.1$$ a pour valeur d√©cimale $$89$$. 
  
| $$2^{7}$$| $$2^{6}$$| $$2^{5}$$ | $$2^{4}$$ | $$2^{3}$$	 |	 $$2^{2}$$  | $$2^{1}$$   | $$2^{0}$$  | 
| :--: | :-----------: |  :-----------: |  :-----------: | :-----------:  |:-----------:  |:-----------:- |
|  | 1| 0| 1| 1 | 0	 |	 0  | 1 |  
 
$$
\begin{aligned}
 1 \times 2^6 + 0 \times 2^5  &+ 0 \times 2^4 + 1\times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 \\  
  	& = 64 +16+8+1   = 89
\end{aligned}
$$

{: .box-warning}
**Exercice 01**   
Retrouve l'√©criture d√©cimale √† partir de l'√©criture binaire des entiers ci-dessous. Reporte le calcul √† effectuer sur ton cahier de brouillon. 
$$
\begin{aligned}
 &11 	&& 1111	&& 10101 \\
 &101	&& 10000	&& 11111
\end{aligned}
$$

{: .box-warning}
**Exercice 02**  
Heureusement, les ordinateurs excellent dans la conversion entre √©criture d√©cimale et binaire.  
	1. On peut rentrer les nombres entiers directement en √©criture binaire, √† condition d'utiliser le pr√©fixe ```0b```. Taper dans la console de votre pythonette ```0b11```; ```0b101```; ```0b1111``` et retrouver les valeurs calcul√©es √† l'exercice pr√©c√©dent.  
	2. Rappeler le r√¥le de l'instruction ```bin()```.  
	3. Donne l'√©criture binaire des nombres entiers $$37$$ et $$139$$.  


{: .box-success} 
**√Ä retenir**  
Le nombre de bits allou√©s √† un nombre binaire d√©termine la grandeur de ce nombre.  
- Avec 4 bits, on peut repr√©senter les nombres de ```0b0000```  √†
```0b1111``` (0 √† 15 en d√©cimal). Soit donc $$2^4 = 16$$ valeurs.  
- Avec 8 bits (un **octet**, on peut repr√©senter les nombres de ```0b00000000``` √†
```0b11111111``` (0 √† 255 en d√©cimal). Soit donc $$2^8 = 256$$ valeurs possibles.  

L'√©criture binaire n√©cessite environ $$\log_2(10)\approx 3.3219 $$ fois plus de chiffres que l'√©criture d√©cimale. Par exemple, pour des entiers d'√©criture d√©cimale √† 10 chiffres, l'√©criture binaire sera sur 32 bits environ.

{: .box-note} 
## Le syst√®me hexad√©cimal

Il s'agit d'un syst√®me de num√©ration en base 16. Il utilise donc 16 symboles, les chiffres arabes pour les dix premiers chiffres (0 √† 9) et les lettres A (= 10 en d√©cimal), B (= 11 en d√©cimal) ... √† F (= 15 en d√©cimal) pour les six suivants.
  
| d√©cimale | hexad√©cimale	 |	 binaire  |   
| :--: | :-----------: | :-----------:  |  
|   0|  ```0```	 |	 ```0000```   | 
|   1|  ```1```	 |	 ```0001```   | 
|   2|  ```2```	 |	 ```0010```   | 
|   3|  ```3```	 |	 ```0011```   | 
|   4|  ```4```	 |	 ```0100```   | 
|   5|  ```5```	 |	 ```0101```   | 
|   6|  ```6```	 |	 ```0110```   | 
|   7|  ```7```	 |	 ```0111```   | 
|   8|  ```8```	 |	 ```1000```   | 
|   9|  ```9```	 |	 ```1001```   | 
|  10|  ```a```	 |	 ```1010```   | 
|  11|  ```b```	 |	 ```1011```   | 
|  12|  ```c```	 |	 ```1100```   | 
|  13|  ```d```	 |	 ```1101```   | 
|  14|  ```e```	 |	 ```1110```   | 
|  15|  ```f```	 |	 ```1111```   |   


Par exemple :

| $$16^{4}$$ | $$16^{3}$$	 |	 $$16^{2}$$  | $$16^{1}$$   | $$16^{0}$$  | 
| :--: | :-----------: | :-----------:  |:-----------:  |:-----------:- |
|  |  	 |	 4  | D | 5 |  

$$ 4D5_\text{hex} = 4\times 16^{2} + 13\times 16^{1}+ 5\times 16^{0} = 1237_{base 10}$$

{: .box-warning}
**Exercice 03** avec Python  
	1. Retrouve l'√©criture d√©cimale √† partir de l'√©criture hexad√©cimale des entiers ci-dessous. Reporte le calcul √† effectuer sur ton cahier de brouillon.  
	$$
	\begin{aligned}
	 &11 	&& 6C	&& 9CC && a4b6 && da47
	\end{aligned}  
	$$  
	2. On peut rentrer les nombres entiers directement en √©criture hexad√©cimale, √† condition d'utiliser le pr√©fixe ```0x```. Taper dans la console de votre pythonette ```0x11```; ```0x6C```; ```0x9CC``` et retrouver les valeurs calcul√©es √† l'exercice pr√©c√©dent.

{: .box-success} 
**√Ä retenir** Conversion binaire $$\leftrightarrow$$ hexad√©cimal   
Le syst√®me hexad√©cimal est utilis√© notamment en informatique car permet un compromis entre le code binaire des machines et une base de num√©ration pratique √† utiliser pour les ing√©nieurs. 
 
Pour convertir ```101111100001```. On regroupe les bits par groupes de 4 : ```1011 1110 0001```.
La table donne en hexad√©cimal ```0xbe1```.

On pourra compl√©ter le groupe de gauche pour qu'il fasse 4 chiffres. Par exemple, pour ```10 0001 1111 1101```, on obtient ```0010 0001 1111 1101``` ce qui donne en hexad√©cimal :```0x21fd```.


{: .box-warning}
**Exercice 04**  
	1. Convertir les √©critures binaires suivantes en hexad√©cimales.
	$$
	\begin{aligned}
	 &1001111111 	&& 100010011110	&& 10011101110  
	\end{aligned}
	$$  
	2. Convertir les √©critures hexad√©cimales en √©critures binaires  
	$$   
	\begin{aligned}
	 &6c 	&& 9cc	&& da47  
	\end{aligned}
	$$   
	3. Combien de chiffres sont n√©cessaires pour repr√©senter un la valeur d'un octet en √©criture hexad√©cimale ?  
	4. Combien de valeurs diff√©rentes peut prendre un nombre √† 2 chiffres en √©criture hexad√©cimale ?   
	5. Le code par d√©faut WPA2 du wifi de votre boxinternet √† la maison est g√©n√©ralement donn√© en hexad√©cimal. Quelle1 est la longueur de ce code ? 

{: .box-note} 
## Application : les adresses MAC
Une **adresse MAC** est un identifiant physique  qui sert dans la plupart des syst√®mes r√©seaux qu'ils soient filaires (Ethernet, ATM,...) ou sans fil (Bluetooth, Wi-Fi,...). Tout objet capable de communiquer sur un r√©seau a une adresse MAC. Des objets avec plusieurs p√©riph√©riques r√©seau auront plusieurs adresses MAC associ√©es √† chaque p√©riph√©rique du r√©seau. Imprimantes, PC, routeurs Ethernet ou wifi ont tous une adresse MAC.  
  
Une adresse MAC est constitu√©e de **48 bits ( 6  octets )** que l'on repr√©sente en 6  groupes de 2 chiffres hexad√©cimaux :  ``` NN:NN:NN:DD:DD:DD``` :
- La premi√®re moiti√© indique le fabriquant de la carte r√©seau. 
- La seconde moiti√© indique le num√©ro de s√©rie de la carte. 

Par exemple : ```00:1C:B3:4F:25:FE``` est une carte de r√©seau fabriqu√©e par Apple. 
 
{: .box-warning}
**Exercice 05**  
	1. Quel est le nombre d'adresse MAC diff√©rentes possibles ?   
	2. Retrouver l'adresse MAC du p√©riph√©rique wifi de votre t√©l√©phone.   

{: .box-warning}
**Travail de recherche**  
	En plus de la gestion des connections. Les adresses MAC peuvent servir √† **filtrer les connexions** et 
	**identifier un appareil**.     
	Faire une recherche sur des utilisations d'adresses MAC des cartes wifi des smartphones pour **pister des utilisateurs uniques** dans l'espace public. Vous donnerez un r√©sum√© de quelques lignes et un **hyperlien**.
	
{: .box-note} 
## Le codage des caract√®res ASCII et unicode

Un caract√®re est stock√© par l'ordinateur sous la forme d'un entier. Pour l'utilisation commerciale de centres de donn√©es, IBM a contribu√© √† installer le codage ASCII (American Standard Code for Information Interchange ) .C'est la norme de codage de caract√®res la plus influente √† ce jour. 

ASCII d√©finit ```128``` codes √† ```7``` bits , comprenant ```95``` caract√®res imprimables : les chiffres de ```0``` √† ```9```, les lettres minuscules et capitales de A √† Z, et des symboles math√©matiques et de ponctuation. 

On a rajout√© un 8e bit pour √©tendre la norme ASCII et incorporer des caract√®res accentu√©s (sur les ```128``` codes suivants).

<p align="center" markdown="1"> 
	![√©cran de la numworks](https://i.imgur.com/Bmbgq0t.png )
</p> 
  
Dans la norme ASCII un octet (8bit) correspond √† un caract√®re. Un fichier de taille 5ko (lire kilo-octet), correspond √† environ 5000 caract√®res. Par exemple ```Lyna``` correspond √† ```76.121.110.97```, donc en binaire ```01001100.01111001.01101110.01100001```.

{: .box-warning}
**Exercie 06**  
Pour les caract√®res en langue Fran√ßaise, on peut utiliser une norm√© compl√©t√©e [des codes ASCII](https://fr.wikipedia.org/wiki/Page_de_code_850). 
D√©terminer les codes ASCII de ton pr√©nom.
 
Cette correspondance 1 octet = 1 caract√®re est moins vraie aujourd'hui. Chaque groupe linguistique a r√©adapt√© la norme ASCII, ce qui rendait d√©licat l'utilisation simultan√©e de plusieurs langues dans un m√™me document ou page web  (une th√®se en h√©breux sur la Gr√®ce antique par exemple, ou un texte arabe avec traduction en japonais). Le codage des caract√®res en Unicode avec **2 octets par caract√®re** a eu du mal √† s'imposer pour la simple raison que les anglophones √©taient tr√®s satisfait de la norme ASCII.

{: .box-warning}
**Exercie 07**  
	1. L'instruction ```chr()``` prend en entr√©e un code entier  et renvoie le caract√®re associ√© √† un code.  
	- Tester les instructions ```chr(65)``` et ```chr(123)```   
	- Tester l'instructions ```chr(128526)``` (basthon).     
	2.  L'instruction ```ord()``` prend pour entr√©e un caract√®re et renvoie son Unicode.   
	Tester les instructions ```ord("A")``` et ```ord("*")```.  
	3. 	Que renvoie l'instruction ```chr(ord("a")-32)``` ?  

Avec l'arriv√©e des smartphones, les informaticiens ont √©t√© contraints d'adopter une norme commune. Ce sera l'**UTF-8** (*Universal Character Set Transformation Format1 - 8 bits*) aujourd‚Äôhui totalement compatible avec le standard Unicode, en restant compatible avec l'ASCII tr√®s largement r√©pandue depuis des d√©cennies<label for="One" class="margin-toggle sidenote-number"></label>. <input type="checkbox" id="One" class="margin-toggle" /><span class="sidenote" align="left" markdown="1">Un [article bien d√©taill√©](https://kunststube.net/encoding/) sur la difficile adoption d'une norme de codage pour les caract√®res </span> L'UTF-8 permet m√™me de g√©rer les emojis üêìü•öüç≥ ! 

{: .box-warning}
**Exercie 08**  
	Quel est l'unicode de l'emoji üòé ?
 

